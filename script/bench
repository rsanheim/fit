#!/usr/bin/env bash
# Consolidated benchmark script for git-all implementations
# shellcheck source-path=SCRIPTDIR
source "$(dirname "$0")/lib.sh"

# Defaults
WARMUP=2
MIN_RUNS=5
BENCH_DIR=""
HYPERFINE_OPTS=()

# Subcommand-specific defaults
CMD="status"
WORKERS="8"
IMPL="rust"
WORKER_LIST="1,2,4,8,12,16"

show_help() {
    cat <<'EOF'
bench - Benchmark git-all implementations

Usage: bench <subcommand> [options] [-- hyperfine-flags]

Subcommands:
  compare   Compare all implementations head-to-head
  git       Compare git commits/branches of an implementation
  scale     Test worker scaling for an implementation
  suite     Run full benchmark suite with markdown output
  help      Show this help message

Global Options:
  -h, --help              Show help
  -d, --dir DIR           Run benchmarks in DIR (default: current directory)
  -w, --warmup N          Warmup runs (default: 2)
  -m, --min-runs N        Minimum benchmark runs (default: 5)
  -i, --ignore-failure    Continue on non-zero exit codes
  --show-output           Show command stdout/stderr

compare Options:
  -c, --cmd CMD           Git command to benchmark (default: status)
  -n, --workers N         Number of workers (default: 8)

scale Options:
  -I, --impl IMPL         Implementation to test (default: rust)
  -c, --cmd CMD           Git command to benchmark (default: status)
  -n, --workers LIST      Comma-separated worker counts (default: 1,2,4,8,12,16)

git Options:
  -I, --impl IMPL         Implementation to compare (default: rust)
  -b, --baseline REF      Baseline git ref (default: main)
  -t, --target REF        Target git ref (default: HEAD)
  -c, --cmd CMD           Git command to benchmark (default: status)
  -n, --workers N         Number of workers (default: 8)

Examples:
  bench compare -d ~/src                # compare impls in ~/src directory
  bench compare -c fetch -n 4           # compare on fetch with 4 workers
  bench compare --show-output -i        # debug failures
  bench git -b main -d ~/src             # compare HEAD vs main branch
  bench git -t fix-branch -c fetch       # compare fix-branch vs main on fetch
  bench scale -I zig -n 1,2,4,8         # test zig scaling
  bench suite -d ~/src > results.md     # generate markdown report
  bench compare -- --export-json out.json
EOF
}

show_subcommand_help() {
    local subcmd="$1"
    case "$subcmd" in
        compare)
            cat <<'EOF'
bench compare - Compare all implementations head-to-head

Usage: bench compare [options] [-- hyperfine-flags]

Options:
  -c, --cmd CMD       Git command to benchmark (default: status)
  -n, --workers N     Number of workers (default: 8)

Global options (-d, -w, -m, -i, --show-output) also apply.
EOF
            ;;
        scale)
            cat <<'EOF'
bench scale - Test worker scaling for an implementation

Usage: bench scale [options] [-- hyperfine-flags]

Options:
  -I, --impl IMPL       Implementation to test (default: rust)
  -c, --cmd CMD         Git command to benchmark (default: status)
  -n, --workers LIST    Comma-separated worker counts (default: 1,2,4,8,12,16)

Global options (-d, -w, -m, -i, --show-output) also apply.
EOF
            ;;
        suite)
            cat <<'EOF'
bench suite - Run full benchmark suite with markdown output

Usage: bench suite [options]

Runs head-to-head comparisons and scaling tests for all implementations.
Output is markdown-formatted, suitable for piping to a file:

  bench suite > docs/benchmark-results.md

Global options (-d, -w, -m, -i, --show-output) also apply.
EOF
            ;;
        git)
            cat <<'EOF'
bench git - Compare git commits/branches of an implementation

Usage: bench git [options] [-- hyperfine-flags]

Builds binaries from two git refs and compares their performance.
Binaries are saved to /tmp with descriptive names (e.g., git-all-rust-main-abc123).

Options:
  -I, --impl IMPL       Implementation to compare (default: rust)
  -b, --baseline REF    Baseline git ref (default: main)
  -t, --target REF      Target git ref (default: HEAD)
  -c, --cmd CMD         Git command to benchmark (default: status)
  -n, --workers N       Number of workers (default: 8)

Global options (-d, -w, -m, -i, --show-output) also apply.

Examples:
  bench git                               # compare HEAD vs main
  bench git -b v0.1.0 -t v0.2.0           # compare tagged versions
  bench git -c fetch -d ~/src/oss         # compare fetch in ~/src/oss
EOF
            ;;
    esac
}

# Handle global options that take an argument (-d, -w, -m)
parse_global_opt_with_arg() {
    case "$1" in
        -d|--dir) BENCH_DIR="$2" ;;
        -w|--warmup) WARMUP="$2" ;;
        -m|--min-runs) MIN_RUNS="$2" ;;
    esac
}

# Handle global options that are flags (-i, --show-output)
parse_global_opt_flag() {
    HYPERFINE_OPTS+=("$1")
}

cmd_compare() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_subcommand_help compare; exit 0 ;;
            -c|--cmd) CMD="$2"; shift 2 ;;
            -n|--workers) WORKERS="$2"; shift 2 ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; HYPERFINE_OPTS+=("$@"); break ;;
            -*) echo "Unknown option: $1"; exit 1 ;;
            *)
                echo "Unexpected argument: $1"
                echo "Use '-c CMD' to specify command (e.g., -c pull)"
                exit 1
                ;;
        esac
    done

    mapfile -t IMPLEMENTATIONS < <(discover_implementations)
    [[ ${#IMPLEMENTATIONS[@]} -eq 0 ]] && { echo "No implementations found in ${BIN_DIR}"; exit 1; }

    echo "=== Benchmarking: git-all $CMD (workers=$WORKERS) ==="
    echo "Implementations: ${IMPLEMENTATIONS[*]}"
    echo

    CMDS=()
    for impl in "${IMPLEMENTATIONS[@]}"; do
        name=$(basename "$impl")
        if [[ -n "$BENCH_DIR" ]]; then
            CMDS+=("-n" "$name" "cd '$BENCH_DIR' && $impl -n $WORKERS $CMD")
        else
            CMDS+=("-n" "$name" "$impl -n $WORKERS $CMD")
        fi
    done

    hyperfine --warmup "$WARMUP" --min-runs "$MIN_RUNS" "${HYPERFINE_OPTS[@]}" "${CMDS[@]}"
}

cmd_scale() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_subcommand_help scale; exit 0 ;;
            -I|--impl) IMPL="$2"; shift 2 ;;
            -c|--cmd) CMD="$2"; shift 2 ;;
            -n|--workers) WORKER_LIST="$2"; shift 2 ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; HYPERFINE_OPTS+=("$@"); break ;;
            -*) echo "Unknown option: $1"; exit 1 ;;
            *)
                echo "Unexpected argument: $1"
                echo "Use '-I IMPL' to specify implementation (e.g., -I zig)"
                exit 1
                ;;
        esac
    done

    IMPL_BIN="${BIN_DIR}/git-all-${IMPL}"

    if [[ ! -x "$IMPL_BIN" ]]; then
        echo "Implementation not found: $IMPL_BIN"
        echo "Available: $(discover_impl_names | tr '\n' ' ')"
        exit 1
    fi

    echo "=== Worker Scaling: git-all-${IMPL} $CMD ==="
    echo "Workers: $WORKER_LIST"
    echo

    local bench_cmd="$IMPL_BIN -n {workers} $CMD"
    [[ -n "$BENCH_DIR" ]] && bench_cmd="cd '$BENCH_DIR' && $bench_cmd"

    hyperfine \
        --warmup "$WARMUP" \
        --min-runs "$MIN_RUNS" \
        "${HYPERFINE_OPTS[@]}" \
        -L workers "$WORKER_LIST" \
        "$bench_cmd"
}

cmd_git() {
    local BASELINE_REF="main"
    local TARGET_REF="HEAD"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_subcommand_help git; exit 0 ;;
            -I|--impl) IMPL="$2"; shift 2 ;;
            -b|--baseline) BASELINE_REF="$2"; shift 2 ;;
            -t|--target) TARGET_REF="$2"; shift 2 ;;
            -c|--cmd) CMD="$2"; shift 2 ;;
            -n|--workers) WORKERS="$2"; shift 2 ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; HYPERFINE_OPTS+=("$@"); break ;;
            -*) echo "Unknown option: $1"; exit 1 ;;
            *)
                echo "Unexpected argument: $1"
                echo "Use '-b REF' for baseline or '-t REF' for target"
                exit 1
                ;;
        esac
    done

    # Save current state (for display only; worktrees avoid touching the main tree)
    local ORIGINAL_REF
    ORIGINAL_REF=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || git rev-parse HEAD)

    local WORKTREE_BASELINE_DIR=""
    local WORKTREE_TARGET_DIR=""

    cleanup() {
        if [[ -n "${WORKTREE_BASELINE_DIR:-}" ]]; then
            git worktree remove --force "$WORKTREE_BASELINE_DIR" 2>/dev/null || true
            rm -rf "$WORKTREE_BASELINE_DIR" || true
        fi
        if [[ -n "${WORKTREE_TARGET_DIR:-}" ]]; then
            git worktree remove --force "$WORKTREE_TARGET_DIR" 2>/dev/null || true
            rm -rf "$WORKTREE_TARGET_DIR" || true
        fi
    }
    trap cleanup EXIT

    # Resolve refs to short SHAs for naming
    local BASELINE_SHA TARGET_SHA
    BASELINE_SHA=$(git rev-parse --short "$BASELINE_REF")
    TARGET_SHA=$(git rev-parse --short "$TARGET_REF")

    # Use the ref as the display name (branch name, tag, or SHA)
    # The SHA suffix in the binary path ensures uniqueness even if the ref moves
    local BASELINE_NAME="$BASELINE_REF"
    local TARGET_NAME="$TARGET_REF"

    local BASELINE_BIN="/tmp/git-all-${IMPL}-${BASELINE_NAME}-${BASELINE_SHA}"
    local TARGET_BIN="/tmp/git-all-${IMPL}-${TARGET_NAME}-${TARGET_SHA}"

    local BUILD_CMD
    BUILD_CMD=$(get_build_cmd "$IMPL" "release")

    get_worktree_binary_path() {
        local root="$1"
        local impl="$2"
        case "$impl" in
            rust)    echo "${root}/rust/target/release/git-all" ;;
            zig)     echo "${root}/zig/zig-out/bin/git-all" ;;
            crystal) echo "${root}/crystal/bin/git-all" ;;
            *)       return 1 ;;
        esac
    }

    echo "=== bench git: configuration ==="
    echo "Implementation:  $IMPL"
    echo "Command:         $CMD"
    echo "Workers:         $WORKERS"
    [[ -n "$BENCH_DIR" ]] && echo "Bench directory: $BENCH_DIR"
    echo "Starting ref:    $ORIGINAL_REF"
    echo

    echo "=== bench git: resolving refs ==="
    echo "Baseline ref: $BASELINE_REF → $BASELINE_SHA"
    echo "Target ref:   $TARGET_REF → $TARGET_SHA"
    echo

    # Build baseline
    echo "=== bench git: building baseline ==="
    if [[ -x "$BASELINE_BIN" ]]; then
        echo "Using cached binary: $BASELINE_BIN"
    else
        WORKTREE_BASELINE_DIR=$(mktemp -d -t "git-all-bench-${IMPL}-baseline-XXXXXX")
        echo "Creating baseline worktree: $WORKTREE_BASELINE_DIR"
        git worktree add --detach "$WORKTREE_BASELINE_DIR" "$BASELINE_SHA"
        local VERIFIED_SHA
        VERIFIED_SHA=$(git -C "$WORKTREE_BASELINE_DIR" rev-parse --short HEAD)
        echo "Verified HEAD: $VERIFIED_SHA"
        echo "Build command: $BUILD_CMD"
        (cd "$WORKTREE_BASELINE_DIR/$IMPL" && $BUILD_CMD)
        local BASELINE_BINARY_PATH
        BASELINE_BINARY_PATH=$(get_worktree_binary_path "$WORKTREE_BASELINE_DIR" "$IMPL")
        cp "$BASELINE_BINARY_PATH" "$BASELINE_BIN"
        echo "Copied binary: $BASELINE_BIN"
    fi
    echo

    # Build target
    echo "=== bench git: building target ==="
    if [[ -x "$TARGET_BIN" ]]; then
        echo "Using cached binary: $TARGET_BIN"
    else
        WORKTREE_TARGET_DIR=$(mktemp -d -t "git-all-bench-${IMPL}-target-XXXXXX")
        echo "Creating target worktree: $WORKTREE_TARGET_DIR"
        git worktree add --detach "$WORKTREE_TARGET_DIR" "$TARGET_SHA"
        VERIFIED_SHA=$(git -C "$WORKTREE_TARGET_DIR" rev-parse --short HEAD)
        echo "Verified HEAD: $VERIFIED_SHA"
        echo "Build command: $BUILD_CMD"
        (cd "$WORKTREE_TARGET_DIR/$IMPL" && $BUILD_CMD)
        local TARGET_BINARY_PATH
        TARGET_BINARY_PATH=$(get_worktree_binary_path "$WORKTREE_TARGET_DIR" "$IMPL")
        cp "$TARGET_BINARY_PATH" "$TARGET_BIN"
        echo "Copied binary: $TARGET_BIN"
    fi
    echo

    # Pre-flight check: compare binaries
    echo "=== bench git: pre-flight check ==="
    local BASELINE_HASH TARGET_HASH
    BASELINE_HASH=$(shasum -a 256 "$BASELINE_BIN" | awk '{print $1}')
    TARGET_HASH=$(shasum -a 256 "$TARGET_BIN" | awk '{print $1}')
    echo "Baseline: $BASELINE_BIN (sha256: ${BASELINE_HASH:0:12}...)"
    echo "Target:   $TARGET_BIN (sha256: ${TARGET_HASH:0:12}...)"
    if [[ "$BASELINE_HASH" == "$TARGET_HASH" ]]; then
        echo "Binaries differ: no"
        echo "WARNING: binaries are identical -- same commit, same toolchain, or build cache issue?"
    else
        echo "Binaries differ: yes"
    fi
    echo

    echo "=== bench git: running benchmark ==="
    echo "Command: git-all $CMD (workers=$WORKERS)"
    echo "Baseline: $BASELINE_NAME ($BASELINE_SHA)"
    echo "Target:   $TARGET_NAME ($TARGET_SHA)"
    echo

    local BASELINE_CMD="$BASELINE_BIN -n $WORKERS $CMD"
    local TARGET_CMD="$TARGET_BIN -n $WORKERS $CMD"
    [[ -n "$BENCH_DIR" ]] && BASELINE_CMD="cd '$BENCH_DIR' && $BASELINE_CMD"
    [[ -n "$BENCH_DIR" ]] && TARGET_CMD="cd '$BENCH_DIR' && $TARGET_CMD"

    hyperfine \
        --warmup "$WARMUP" \
        --min-runs "$MIN_RUNS" \
        "${HYPERFINE_OPTS[@]}" \
        -n "$BASELINE_NAME-$BASELINE_SHA" "$BASELINE_CMD" \
        -n "$TARGET_NAME-$TARGET_SHA" "$TARGET_CMD"
}

cmd_suite() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_subcommand_help suite; exit 0 ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; break ;;
            -*) echo "Unknown option: $1"; exit 1 ;;
            *)
                echo "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    echo "# Benchmark Results - $(date '+%Y-%m-%d')"
    echo
    echo "## Environment"
    echo
    echo "* $(uname -s) $(uname -r)"
    echo "* $(sysctl -n hw.ncpu 2>/dev/null || nproc) CPU cores"
    echo "* Implementations: $(discover_impl_names | tr '\n' ' ')"
    echo

    for cmd in status fetch; do
        echo "## $cmd - Head to Head"
        echo
        echo '```'
        CMD="$cmd" WORKERS="8" cmd_compare 2>&1
        echo '```'
        echo
    done

    echo "## Worker Scaling (status)"
    echo
    for impl in $(discover_impl_names); do
        echo "### git-all-${impl}"
        echo
        echo '```'
        IMPL="$impl" CMD="status" WORKER_LIST="1,2,4,8" cmd_scale 2>&1
        echo '```'
        echo
    done
}

main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                if [[ $# -eq 1 ]]; then
                    show_help
                    exit 0
                fi
                break  # Let subcommand handle its own -h
                ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; HYPERFINE_OPTS+=("$@"); break ;;
            -*)
                # Check if this is a known subcommand option, if so let subcommand handle it
                break
                ;;
            *) break ;;
        esac
    done

    SUBCOMMAND="${1:-compare}"
    shift || true

    if [[ -z "$BENCH_DIR" && "$SUBCOMMAND" != "help" ]]; then
        if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            echo "bench: current directory is a git repository."
            echo "Please pass -d/--dir to run benchmarks in a parent directory of multiple repos."
            exit 1
        fi
    fi

    case "$SUBCOMMAND" in
        compare) cmd_compare "$@" ;;
        git) cmd_git "$@" ;;
        scale) cmd_scale "$@" ;;
        suite) cmd_suite "$@" ;;
        help) show_help ;;
        *)
            echo "Unknown subcommand: $SUBCOMMAND"
            echo "Run 'bench help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
